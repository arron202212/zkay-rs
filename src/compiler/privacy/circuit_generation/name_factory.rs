use crate::zkay_ast::ast::{Expression, HybridArgType, HybridArgumentIdf, Identifier, TypeName};
#[derive(Clone)]
pub struct BaseNameFactory {
    pub base_name: String,
    pub count: i32,
}
// class BaseNameFactory:
// """A Base name factory can generate fresh, unused name strings with a given prefix"""
impl BaseNameFactory {
    pub fn new(base_name: String) -> Self {
        Self {
            base_name,
            count: 0,
        }
    }

    pub fn get_new_name(&mut self, t: TypeName, inc: bool) -> String
// """
        // Generate a fresh name for a value of type t.

        // :param t: transformed type
        // :param inc: if true, the internal counter, which is used as part of fresh ids, is incremented
        // """
    {
        let postfix = if t.is_key() {
            "key"
        } else if t.is_cipher() {
            "cipher"
        } else if t.is_randomness() {
            "rnd"
        } else {
            "plain"
        };
        let name = format!("{}{}_{postfix}", self.base_name, self.count);
        if inc {
            self.count += 1;
        }
        name
    }
}

// class NameFactory(BaseNameFactory):
// """A Name factory can generate fresh, unused HybridArgumentIdfs with a given prefix."""
#[derive(Clone)]
pub struct NameFactory {
    pub base_name_factory: BaseNameFactory,
    pub arg_type: HybridArgType,
    pub size: i32,
    pub idfs: Vec<Identifier>,
}
impl NameFactory {
    pub fn new(base_name: String, arg_type: HybridArgType) -> Self {
        // super().__init__(base_name)
        // self.arg_type = arg_type
        // self.size = 0
        // self.idfs = []
        Self {
            base_name_factory: BaseNameFactory::new(base_name),
            arg_type,
            size: 0,
            idfs: vec![],
        }
    }
    pub fn get_new_idf(&mut self, t: TypeName, priv_expr: Option<Expression>) -> HybridArgumentIdf
// """Generate a new HybridArgumentIdf which references priv_expr and has transformed type t."""
    {
        let name = self.base_name_factory.get_new_name(t, true);
        let idf = HybridArgumentIdf::new(name, t.clone(), self.arg_type.clone(), priv_expr);
        self.size += t.size_in_uints();
        self.idfs.push(Identifier::HybridArgumentIdf(idf.clone()));
        idf
    }

    pub fn add_idf(
        &mut self,
        name: String,
        t: TypeName,
        priv_expr: Option<Expression>,
    ) -> HybridArgumentIdf
// """
    // Generate a new HybridArgumentIdf with the given name.

    // This also adds the HybridArgumentIdf to the internal list of identifiers generated by this NameFactory.
    // """
    {
        let idf = HybridArgumentIdf::new(name, t.clone(), self.arg_type.clone(), priv_expr);
        self.base_name_factory.count += 1;
        self.size += t.size_in_uints();
        self.idfs.push(Identifier::HybridArgumentIdf(idf.clone()));
        idf
    }
}
