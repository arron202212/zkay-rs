use crate::zkay_ast::ast::{Expression, HybridArgType, HybridArgumentIdf, TypeName};

struct BaseNameFactory {
    base_name: String,
    count: i32,
}
// class BaseNameFactory:
// """A Base name factory can generate fresh, unused name strings with a given prefix"""
impl BaseNameFactory {
    pub fn new(base_name: String) -> Self {
        Self {
            base_name,
            count: 0,
        }
    }

    pub fn get_new_name(&mut self, t: TypeName, inc: bool) -> String
// """
        // Generate a fresh name for a value of type t.

        // :param t: transformed type
        // :param inc: if True, the internal counter, which is used as part of fresh ids, is incremented
        // """
    {
        let postfix = if t.is_key() {
            "key"
        } else if t.is_cipher() {
            "cipher"
        } else if t.is_randomness() {
            "rnd"
        } else {
            "plain"
        };
        let name = format!("{}{}_{postfix}", self.base_name, self.count);
        if inc {
            self.count += 1;
        }
        name
    }
}

// class NameFactory(BaseNameFactory):
// """A Name factory can generate fresh, unused HybridArgumentIdfs with a given prefix."""
pub struct NameFactory {
    base_name_factory: BaseNameFactory,
    arg_type: HybridArgType,
    size: i32,
    idfs: Vec<Identifier>,
}
impl NameFactory {
    pub fn new(base_name: String, arg_type: HybridArgType) -> Self {
        // super().__init__(base_name)
        // self.arg_type = arg_type
        // self.size = 0
        // self.idfs = []
        Self {
            base_name_factory: BaseNameFactory::new(base_name),
            arg_type,
            size: 0,
            idfs: vec![],
        }
    }
    pub fn get_new_idf(&mut self, t: TypeName, priv_expr: Option<Expression>) -> HybridArgumentIdf
// """Generate a new HybridArgumentIdf which references priv_expr and has transformed type t."""
    {
        let name = self.get_new_name(t, True);
        let idf = HybridArgumentIdf(name, t, self.arg_type, priv_expr);
        self.size += t.size_in_uints;
        self.idfs.push(idf);
        idf
    }

    pub fn add_idf(&mut self, name: String, t: TypeName, priv_expr: Option<Expression>)
    // """
    // Generate a new HybridArgumentIdf with the given name.

    // This also adds the HybridArgumentIdf to the internal list of identifiers generated by this NameFactory.
    // """
    {
        let idf = HybridArgumentIdf(name, t, self.arg_type, priv_expr);
        self.count += 1;
        self.size += t.size_in_uints;
        self.idfs.push(idf);
        idf
    }
}
