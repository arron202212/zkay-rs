use crate::circuit::config::config::Configs;
use crate::circuit::eval::circuit_evaluator::CircuitEvaluator;

use crate::circuit::eval::instruction::Instruction;
use crate::circuit::operations::gadget;
use crate::circuit::structure::constant_wire;
use crate::circuit::structure::wire_type::WireType;
use examples::gadgets::math::field_division_gadget;

/**
 * This gadget implements cryptographic key exchange using a customized elliptic
 * curve that is efficient to represent as a SNARK circuit. It follows the
 * high-level guidelines used for the design of Curve25519, while having the
 * cost model of QAP-based SNARKs in mind. Details in section 6:
 * https://eprint.iacr.org/2015/1093.pdf
 *
 * Detailed comments about the inputs and outputs of the circuit are below.
 *
 * Note: By default, this gadget validates only the secret values that are
 * provided by the prover, such as the secret key, and any intermediate
 * auxiliary witnesses that the prover uses in the circuit. In the default mode,
 * the gadget does not check the pub  input keys, e.g. it does not verify that
 * the base point or the other party's input have the appropriate order, as such
 * inputs could be typically pub  and can be checked outside the circuit if
 * needed. The Curve25519 paper as well claims that validation is not necessary
 * (although there is debate about some cases online). If any validation is
 * desired, there is a separate method called validateInputs() that do
 * validation, but is not called by default.
 *
 *
 *
 */

pub struct AffinePoint {
    x: WireType,
    y: WireType,
    // AffinePoint(x:WireType) {
    // 	self.x = x;
    // }

    // AffinePoint(x:WireType, y:WireType) {
    // 	self.x = x;
    // 	self.y = y;
    // }

    // AffinePoint(p:AffinePoint) {
    // 	self.x = p.x;
    // 	self.y = p.y;
    // }
}
pub struct ECDHKeyExchangeGadget {
    // The Affine point representation is used as it saves one gate per bit
    basePoint: AffinePoint, // The Base point both parties agree to
    hPoint: AffinePoint,    // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    secretBits: Vec<WireType>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget outputs
    outputPublicValue: WireType, // the x-coordinate of the key exchange
    // material to be sent to the other party
    // outputPublicValue = ((this party's
    // secret)*Base).x
    sharedSecret: WireType, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    baseTable: Vec<AffinePoint>,
    hTable: Vec<AffinePoint>,
}
impl ECDHKeyExchangeGadget {
    // Note: this parameterization assumes that the underlying field has
    // Configs.get().unwrap().field_prime =
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617

    pub const SECRET_BITWIDTH: i32 = 253; // number of bits in the
    // exponent. Note that the
    // most significant bit
    // should
    // be set to 1, and the
    // three least significant
    // bits should be be zero.
    // See
    // the constructor

    pub const COEFF_A: BigInteger = BigInteger::new("126932"); // parameterization
    // in
    // https://eprint.iacr.org/2015/1093.pdf

    pub const CURVE_ORDER: BigInteger = BigInteger::new(
        "21888242871839275222246405745257275088597270486034011716802747351550446453784",
    );

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    pub const SUBGROUP_ORDER: BigInteger = BigInteger::new(
        "2736030358979909402780800718157159386074658810754251464600343418943805806723",
    );
    /**
     * This gadget receives two points: Base = (baseX) and H = (hX), and the
     * secret key Bits and outputs the scalar EC multiplications: secret*Base,
     * secret*H
     *
     * The secret key bits must be of length SECRET_BITWIDTH and are expected to
     * follow a little endian order. The most significant bit should be 1, and
     * the three least significant bits should be zero.
     *
     * This gadget can work with both  and dynamic inputs If pub  keys
     * are , the wires of base and h should be made ConstantWires when
     * creating them (before calling this gadget).
     *
     *
     */

    pub fn new(baseX: WireType, hX: WireType, secretBits: Vec<WireType>, desc: Vec<String>) {
        super(desc);
        self.secretBits = secretBits;
        self.basePoint = AffinePoint::new(baseX);
        self.hPoint = AffinePoint::new(hX);
        checkSecretBits();
        computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinates
        buildCircuit();
    }
}
impl Gadget for ECDHKeyExchangeGadget {
    // same constructor as before, but accepts also baseY, and hY as inputs
    pub fn new(
        baseX: WireType,
        baseY: WireType,
        hX: WireType,
        hY: WireType,
        secretBits: Vec<WireType>,
        desc: Vec<String>,
    ) -> Self {
        super(desc);

        self.secretBits = secretBits;
        self.basePoint = AffinePoint::new(baseX, baseY);
        self.hPoint = AffinePoint::new(hX, hY);
        checkSecretBits();
        buildCircuit();
    }

    fn buildCircuit() {
        /**
         * The reason this operates on affine coordinates is that in our
         * setting, this's slightly cheaper than the formulas in
         * https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
         * following equations save 1 multiplication gate per bit. (we consider
         * multiplications by constants cheaper in our setting, so they are not
         * counted)
         */
        baseTable = preprocess(basePoint);
        hTable = preprocess(hPoint);
        outputPublicValue = mul(basePoint, secretBits, baseTable).x;
        sharedSecret = mul(hPoint, secretBits, hTable).x;
    }

    fn checkSecretBits() {
        /**
         * The secret key bits must be of length SECRET_BITWIDTH and are
         * expected to follow a little endian order. The most significant bit
         * should be 1, and the three least significant bits should be zero.
         */
        assert!(secretBits.length == SECRET_BITWIDTH);
        generator.addZeroAssertion(secretBits[0], "Asserting secret bit conditions");
        generator.addZeroAssertion(secretBits[1], "Asserting secret bit conditions");
        generator.addZeroAssertion(secretBits[2], "Asserting secret bit conditions");
        generator.addOneAssertion(
            secretBits[SECRET_BITWIDTH - 1],
            "Asserting secret bit conditions",
        );

        for i in 3..SECRET_BITWIDTH - 1 {
            // verifying all other bit wires are binary (as this is typically a
            // secret
            // witness by the prover)
            generator.addBinaryAssertion(secretBits[i]);
        }
    }

    fn computeYCoordinates() {
        // Easy to handle if baseX is constant, otherwise, let the prover input
        // a witness and verify some properties

        if basePoint.x.instanceof(ConstantWire) {
            let x = (basePoint.x).getConstant();
            basePoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            basePoint.y = generator.createProverWitnessWire();
            generator.specifyProverWitnessComputation(&{
                struct Prover;
                impl Instruction for Prover {
                    fn evaluate(&self,evaluator: CircuitEvaluator) {
                        let x = evaluator.getWireValue(basePoint.x);
                        evaluator.setWireValue(basePoint.y, computeYCoordinate(x));
                    }
                }
                Prover
            });
            assertValidPointOnEC(basePoint.x, basePoint.y);
        }

        if hPoint.x.instanceof(ConstantWire) {
            let x = (hPoint.x).getConstant();
            hPoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            hPoint.y = generator.createProverWitnessWire();
            generator.specifyProverWitnessComputation(&{
                struct Prover;
                impl Instruction for Prover {
                    fn evaluate(&self,evaluator: CircuitEvaluator) {
                        let x = evaluator.getWireValue(hPoint.x);
                        evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
                    }
                }
                Prover
            });
            assertValidPointOnEC(hPoint.x, hPoint.y);
        }
    }

    // this is only called, when WireType y is provided as witness by the prover
    // (not as input to the gadget)
    fn assertValidPointOnEC(x: WireType, y: WireType) {
        let ySqr = y.mul(y);
        let xSqr = x.mul(x);
        let xCube = xSqr.mul(x);
        generator.addEqualityAssertion(ySqr, xCube.add(xSqr.mul(COEFF_A)).add(x));
    }

    fn preprocess(p: AffinePoint) -> Vec<AffinePoint> {
        let precomputedTable = vec![AffinePoint::default(); secretBits.length];
        precomputedTable[0] = p;
        for j in 1..secretBits.length {
            precomputedTable[j] = doubleAffinePoint(precomputedTable[j - 1]);
        }
        return precomputedTable;
    }

    /**
     * Performs scalar multiplication (secretBits must comply with the
     * conditions above)
     */
    fn mul(
        p: AffinePoint,
        secretBits: Vec<WireType>,
        precomputedTable: Vec<AffinePoint>,
    ) -> AffinePoint {
        let result = AffinePoint::new(precomputedTable[secretBits.length - 1]);
        for j in (0..=secretBits.length - 2).rev() {
            let tmp = addAffinePoints(result, precomputedTable[j]);
            let isOne = secretBits[j];
            result.x = result.x.add(isOne.mul(tmp.x.sub(result.x)));
            result.y = result.y.add(isOne.mul(tmp.y.sub(result.y)));
        }
        return result;
    }

    fn doubleAffinePoint(p: AffinePoint) -> AffinePoint {
        let x_2 = p.x.mul(p.x);
        let l1 =
            FieldDivisionGadget::new(x_2.mul(3).add(p.x.mul(COEFF_A).mul(2)).add(1), p.y.mul(2))
                .getOutputWires()[0];
        let l2 = l1.mul(l1);
        let newX = l2.sub(COEFF_A).sub(p.x).sub(p.x);
        let newY = p.x.mul(3).add(COEFF_A).sub(l2).mul(l1).sub(p.y);
        return AffinePoint::new(newX, newY);
    }

    fn addAffinePoints(p1: AffinePoint, p2: AffinePoint) -> AffinePoint {
        let diffY = p1.y.sub(p2.y);
        let diffX = p1.x.sub(p2.x);
        let q = FieldDivisionGadget::new(diffY, diffX).getOutputWires()[0];
        let q2 = q.mul(q);
        let q3 = q2.mul(q);
        let newX = q2.sub(COEFF_A).sub(p1.x).sub(p2.x);
        let newY = p1.x.mul(2).add(p2.x).add(COEFF_A).mul(q).sub(q3).sub(p1.y);
        return AffinePoint::new(newX, newY);
    }

    pub fn getOutputWires() -> Vec<WireType> {
        return vec![outputPublicValue, sharedSecret];
    }

    pub fn computeYCoordinate(x: BigInteger) -> BigInteger {
        let xSqred = x.multiply(x).modulo(Configs.get().unwrap().field_prime);
        let xCubed = xSqred.multiply(x).modulo(Configs.get().unwrap().field_prime);
        let ySqred = xCubed
            .add(COEFF_A.multiply(xSqred))
            .add(x)
            .modulo(Configs.get().unwrap().field_prime);
        let y = IntegerFunctions.ressol(ySqred, Configs.get().unwrap().field_prime);
        return y;
    }

    pub fn validateInputs() {
        generator.addOneAssertion(basePoint.x.checkNonZero());
        assertValidPointOnEC(basePoint.x, basePoint.y);
        assertPointOrder(basePoint, baseTable);
        generator.addOneAssertion(hPoint.x.checkNonZero());
        assertValidPointOnEC(hPoint.x, hPoint.y);
        assertPointOrder(basePoint, baseTable);
        assertPointOrder(hPoint, hTable);
    }

    fn assertPointOrder(p: AffinePoint, table: Vec<AffinePoint>) {
        let o = generator.createConstantWire(SUBGROUP_ORDER);
        let bits = o.getBitWires(SUBGROUP_ORDER.bitLength()).asArray();

        let result = AffinePoint::new(table[bits.length - 1]);
        for j in (1..=bits.length - 2).rev() {
            let tmp = addAffinePoints(result, table[j]);
            let isOne = bits[j];
            result.x = result.x.add(isOne.mul(tmp.x.sub(result.x)));
            result.y = result.y.add(isOne.mul(tmp.y.sub(result.y)));
        }

        // verify that: result = -p
        generator.addEqualityAssertion(result.x, p.x);
        generator.addEqualityAssertion(result.y, p.y.mul(-1));

        // the reason the last iteration is handled separately is that the
        // addition of
        // affine points will throw an error due to not finding inverse for zero
        // at the last iteration of the scalar multiplication. So, the check in
        // the last iteration is done manually

        // TODO: add more tests to check this method
    }

    pub fn getOutputPublicValue() -> WireType {
        return outputPublicValue;
    }

    pub fn getSharedSecret() -> WireType {
        return sharedSecret;
    }
}
