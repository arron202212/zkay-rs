#![allow(dead_code)]
//#![allow(non_snake_case)]
//#![allow(non_upper_case_globals)]
//#![allow(nonstandard_style)]
//#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
#![allow(warnings, unused)]
use crate::{
    arc_cell_new,
    bouncycastle_rs::pqc::math::linearalgebra::integer_functions::IntegerFunctions,
    circuit::{
        InstanceOf, StructNameConfig,
        auxiliary::long_element::LongElement,
        config::config::CONFIGS,
        eval::{circuit_evaluator::CircuitEvaluator, instruction::Instruction},
        operations::{
            gadget::{Gadget, GadgetConfig},
            primitive::{
                assert_basic_op::AssertBasicOp, basic_op::BasicOp, mul_basic_op::MulBasicOp,
            },
            wire_label_instruction::LabelType,
            wire_label_instruction::WireLabelInstruction,
        },
        structure::{
            circuit_generator::{CGConfig, CGConfigFields, CircuitGenerator},
            constant_wire::ConstantWire,
            variable_bit_wire::VariableBitWire,
            variable_wire::VariableWire,
            wire::{GetWireId, SetBitsConfig, Wire, WireConfig},
            wire_array::WireArray,
            wire_type::WireType,
        },
    },
    examples::gadgets::math::field_division_gadget::FieldDivisionGadget,
    util::{
        util::ARcCell,
        util::{BigInteger, Util},
    },
};

use rccell::RcCell;
use std::{
    fmt::Debug,
    fs::File,
    hash::{DefaultHasher, Hash, Hasher},
    ops::{Add, Mul, Neg, Rem, Sub},
};
use zkay_derive::ImplStructNameConfig;

//  * This gadget implements cryptographic key exchange using a customized elliptic
//  * curve that is efficient to represent as a SNARK circuit. It follows the
//  * high-level guidelines used for the design of Curve25519, while having the
//  * cost model of QAP-based SNARKs in mind. Details in section 6:
//  * https://eprint.iacr.org/2015/1093.pdf
//  *
//  * Detailed comments about the inputs and outputs of the circuit are below.
//  *
//  * Note: By default, this gadget validates only the secret values that are
//  * provided by the prover, such as the secret key, and any intermediate
//  * auxiliary witnesses that the prover uses in the circuit. In the default mode,
//  * the gadget does not check the pub  input keys, e.g. it does not verify that
//  * the base point or the other party's input have the appropriate order, as such
//  * inputs could be typically pub  and can be checked outside the circuit if
//  * needed. The Curve25519 paper as well claims that validation is not necessary
//  * (although there is debate about some cases online). If any validation is
//  * desired, there is a separate method called validate_inputs() that do
//  * validation, but is not called by default.

#[derive(Debug, Clone, Hash, ImplStructNameConfig)]
pub struct AffinePoint {
    pub x: Option<WireType>,
    pub y: Option<WireType>,
}
impl AffinePoint {
    pub fn newx(x: WireType) -> Self {
        Self {
            x: Some(x),
            y: None,
        }
    }

    pub fn new(x: WireType, y: WireType) -> Self {
        Self {
            x: Some(x),
            y: Some(y),
        }
    }
}

#[derive(Debug, Clone, ImplStructNameConfig)]
pub struct ECDHKeyExchangeGadget {
    // The Affine point representation is used as it saves one gate per bit
    pub base_point: AffinePoint, // The Base point both parties agree to
    pub h_point: AffinePoint,    // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    pub secret_bits: Vec<Option<WireType>>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget outputs
    pub output_public_value: Option<WireType>, // the x-coordinate of the key exchange
    // material to be sent to the other party
    // output_public_value = ((this party's
    // secret)*Base).x
    pub shared_secret: Option<WireType>, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    pub base_table: Vec<AffinePoint>,
    pub h_table: Vec<AffinePoint>,
    pub output: Vec<Option<WireType>>,
}
impl ECDHKeyExchangeGadget {
    //This gadget receives two points: Base = (base_x) and H = (h_x), and the
    //secret key Bits and outputs the scalar EC multiplications: secret*Base,
    //secret*H
    //
    //The secret key bits must be of length SECRET_BITWIDTH and are expected to
    //follow a little endian order. The most significant bit should be 1, and
    //the three least significant bits should be zero.
    //
    //This gadget can work with both  and dynamic inputs If pub  keys
    //are , the wires of base and h should be made ConstantWires when
    //creating them (before calling this gadget).
    //
    //

    #[inline]
    pub fn new(
        base_x: Option<WireType>,
        base_y: Option<WireType>,
        h_x: Option<WireType>,
        h_y: Option<WireType>,
        secret_bits: Vec<Option<WireType>>,
        generator: RcCell<CircuitGenerator>,
    ) -> Gadget<Self> {
        Self::new_with_option(base_x, base_y, h_x, h_y, secret_bits, &None, generator)
    }
    pub fn new_with_option(
        base_x: Option<WireType>,
        base_y: Option<WireType>,
        h_x: Option<WireType>,
        h_y: Option<WireType>,
        secret_bits: Vec<Option<WireType>>,
        desc: &Option<String>,
        generator: RcCell<CircuitGenerator>,
    ) -> Gadget<Self> {
        let y_is_none = h_y.is_none();
        let mut _self = Gadget::<Self>::new(
            generator,
            desc,
            Self {
                output_public_value: None,
                shared_secret: None,
                base_table: vec![],
                h_table: vec![],
                secret_bits,
                base_point: AffinePoint {
                    x: base_x,
                    y: base_y,
                },
                h_point: AffinePoint { x: h_x, y: h_y },
                output: vec![],
            },
        );

        _self.check_secret_bits();
        if y_is_none {
            _self.compute_y_coordinates(); // For efficiency reasons, we rely on affine
        }
        // coordinates
        _self.build_circuit();
        _self
    }
}

impl Gadget<ECDHKeyExchangeGadget> {
    // Note: this parameterization assumes that the underlying field has
    // CONFIGS.field_prime =
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617

    pub const SECRET_BITWIDTH: usize = 253; // number of bits in the
    // exponent. Note that the
    // most significant bit
    // should
    // be set to 1, and the
    // three least significant
    // bits should be be zero.
    // See
    // the constructor

    pub const COEFF_A: &str = "126932"; // parameterization
    // in
    // https://eprint.iacr.org/2015/1093.pdf

    pub const CURVE_ORDER: &str =
        "21888242871839275222246405745257275088597270486034011716802747351550446453784";

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    pub const SUBGROUP_ORDER: &str =
        "2736030358979909402780800718157159386074658810754251464600343418943805806723";
    fn build_circuit(&mut self) {
        //
        // The reason this operates on affine coordinates is that in our
        // setting, this's slightly cheaper than the formulas in
        // https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
        // following equations save 1 multiplication gate per bit. (we consider
        // multiplications by constants cheaper in our setting, so they are not
        // counted)
        //
        let start = std::time::Instant::now();
        self.t.base_table = self.preprocess(&self.t.base_point);

        self.t.h_table = self.preprocess(&self.t.h_point);

        self.t.output_public_value = self
            .mul(&self.t.base_point, &self.t.secret_bits, &self.t.base_table)
            .x
            .clone();
        self.t.shared_secret = self
            .mul(&self.t.h_point, &self.t.secret_bits, &self.t.h_table)
            .x
            .clone();

        self.t.output = vec![
            self.t.output_public_value.clone(),
            self.t.shared_secret.clone(),
        ];
    }

    fn check_secret_bits(&self) {
        let start = std::time::Instant::now();

        //The secret key bits must be of length SECRET_BITWIDTH and are
        //expected to follow a little endian order. The most significant bit
        //should be 1, and the three least significant bits should be zero.

        assert!(self.t.secret_bits.len() == Self::SECRET_BITWIDTH);
        CircuitGenerator::add_zero_assertion_with_str(
            self.generator.clone(),
            self.t.secret_bits[0].as_ref().unwrap(),
            "Asserting secret bit conditions",
        );

        CircuitGenerator::add_zero_assertion_with_str(
            self.generator.clone(),
            self.t.secret_bits[1].as_ref().unwrap(),
            "Asserting secret bit conditions",
        );

        CircuitGenerator::add_zero_assertion_with_str(
            self.generator.clone(),
            self.t.secret_bits[2].as_ref().unwrap(),
            "Asserting secret bit conditions",
        );

        CircuitGenerator::add_one_assertion_with_str(
            self.generator.clone(),
            self.t.secret_bits[Self::SECRET_BITWIDTH - 1]
                .as_ref()
                .unwrap(),
            "Asserting secret bit conditions",
        );

        for i in 3..Self::SECRET_BITWIDTH - 1 {
            // verifying all other bit wires are binary (as this is typically a
            // secret
            // witness by the prover)

            CircuitGenerator::add_binary_assertion(
                self.generator.clone(),
                self.t.secret_bits[i].as_ref().unwrap(),
            );
        }
    }

    fn compute_y_coordinates(&mut self) {
        // Easy to handle if base_x is constant, otherwise, let the prover input
        // a witness and verify some properties
        let start = std::time::Instant::now();
        if self
            .t
            .base_point
            .x
            .as_ref()
            .unwrap()
            .instance_of("ConstantWire")
        {
            let x = self
                .t
                .base_point
                .x
                .as_ref()
                .unwrap()
                .try_as_constant_ref()
                .unwrap()
                .get_constant();
            self.t.base_point.y = Some(CircuitGenerator::create_constant_wire(
                self.generator.clone(),
                &Self::compute_y_coordinate(x),
            ));
        } else {
            self.t.base_point.y = Some(CircuitGenerator::create_prover_witness_wire(
                self.generator.clone(),
            ));

            let base_point = &self.t.base_point;
            let prover = crate::impl_prover!(
                            eval(  base_point: AffinePoint)  {
            impl Instruction for Prover{
             fn evaluate(&self, evaluator: &mut CircuitEvaluator) ->eyre::Result<()>{
                       let x = evaluator.get_wire_value(self.base_point.x.as_ref().unwrap());
            evaluator.set_wire_value(self.base_point.y.as_ref().unwrap(), &Gadget::<ECDHKeyExchangeGadget>::compute_y_coordinate(x));

                Ok(())
            }
            }
                        }
                    );
            CircuitGenerator::specify_prover_witness_computation(self.generator.clone(), prover);

            self.assert_valid_point_on_ec(
                self.t.base_point.x.as_ref().unwrap(),
                self.t.base_point.y.as_ref().unwrap(),
            );
        }

        if self
            .t
            .h_point
            .x
            .as_ref()
            .unwrap()
            .instance_of("ConstantWire")
        {
            let x = self
                .t
                .h_point
                .x
                .as_ref()
                .unwrap()
                .try_as_constant_ref()
                .unwrap()
                .get_constant();
            self.t.h_point.y = Some(CircuitGenerator::create_constant_wire(
                self.generator.clone(),
                &Self::compute_y_coordinate(x),
            ));
        } else {
            self.t.h_point.y = Some(CircuitGenerator::create_prover_witness_wire(
                self.generator.clone(),
            ));

            let h_point = &self.t.h_point;
            let prover = crate::impl_prover!(
                                        eval(  h_point: AffinePoint
                                )  {
                        impl Instruction for Prover{
                         fn evaluate(&self, evaluator: &mut CircuitEvaluator) ->eyre::Result<()>{
                                   let x = evaluator.get_wire_value(self.h_point.x.as_ref().unwrap());
                        evaluator.set_wire_value(self.h_point.y.as_ref().unwrap(), &Gadget::<ECDHKeyExchangeGadget>::compute_y_coordinate(x));
            Ok(())

                        }
                        }
                                    }
                                );
            CircuitGenerator::specify_prover_witness_computation(self.generator.clone(), prover);
            // {
            //         struct Prover;
            //         impl Instruction for Prover {
            //             &|evaluator: &mut CircuitEvaluator| {
            //                 let x = evaluator.get_wire_value(h_point.x);
            //                 evaluator.set_wire_value(h_point.y, compute_y_coordinate(x));
            //             }
            //         }
            //         Prover
            //     });

            self.assert_valid_point_on_ec(
                self.t.h_point.x.as_ref().unwrap(),
                self.t.h_point.y.as_ref().unwrap(),
            );
        }
    }

    // this is only called, when WireType y is provided as witness by the prover
    // (not as input to the gadget)
    fn assert_valid_point_on_ec(&self, x: &WireType, y: &WireType) {
        let start = std::time::Instant::now();
        let y_sqr = y.clone().mul(y);

        let x_sqr = x.clone().mul(x);

        let x_cube = x_sqr.clone().mul(x);

        CircuitGenerator::add_equality_assertion(
            self.generator.clone(),
            &y_sqr,
            &x_cube
                .add(x_sqr.mulb(&Util::parse_big_int(Self::COEFF_A)))
                .add(x),
        );
    }

    fn preprocess(&self, p: &AffinePoint) -> Vec<AffinePoint> {
        let start = std::time::Instant::now();
        let mut precomputed_table: Vec<_> = (1..self.t.secret_bits.len())
            .scan(p.clone(), |s, _j| {
                *s = Self::double_affine_point(&s, self.generator.clone());
                Some((*s).clone())
            })
            .collect();

        precomputed_table.insert(0, p.clone());
        precomputed_table
    }

    //Performs scalar multiplication (secret_bits must comply with the
    //conditions above)

    fn mul(
        &self,
        p: &AffinePoint,
        secret_bits: &Vec<Option<WireType>>,
        precomputed_table: &Vec<AffinePoint>,
    ) -> AffinePoint {
        let start = std::time::Instant::now();
        let mut result = precomputed_table[secret_bits.len() - 1].clone();
        for j in (0..=secret_bits.len() - 2).rev() {
            let tmp = self.add_affine_points(&result, &precomputed_table[j]);

            let is_one = &secret_bits[j];
            result.x = Some(
                result.x.clone().unwrap().add(
                    is_one
                        .clone()
                        .unwrap()
                        .mul(tmp.x.clone().unwrap().sub(result.x.as_ref().unwrap())),
                ),
            );

            result.y = Some(
                result.y.clone().unwrap().add(
                    is_one
                        .clone()
                        .unwrap()
                        .mul(tmp.y.clone().unwrap().sub(result.y.as_ref().unwrap())),
                ),
            );
        }
        result
    }

    fn double_affine_point(p: &AffinePoint, generator: RcCell<CircuitGenerator>) -> AffinePoint {
        let start = std::time::Instant::now();
        let coeff_a = Util::parse_big_int(Self::COEFF_A);
        let x_2 = p.x.clone().unwrap().mul(p.x.as_ref().unwrap());
        let a = x_2
            .muli(3)
            .add(p.x.as_ref().unwrap().mulb(&coeff_a).muli(2))
            .add(1);
        let b = p.y.as_ref().unwrap().muli(2);
        let l1 = FieldDivisionGadget::new(a, b, generator).get_output_wires()[0].clone();

        let l2 = l1.clone().unwrap().mul(l1.as_ref().unwrap());

        let new_x = l2
            .clone()
            .sub(&coeff_a)
            .sub(p.x.clone().unwrap())
            .sub(p.x.as_ref().unwrap());

        let new_y =
            p.x.as_ref()
                .unwrap()
                .muli(3)
                .add(&coeff_a)
                .sub(&l2)
                .mul(l1.as_ref().unwrap())
                .sub(p.y.as_ref().unwrap());

        AffinePoint::new(new_x, new_y)
    }

    fn add_affine_points(&self, p1: &AffinePoint, p2: &AffinePoint) -> AffinePoint {
        let start = std::time::Instant::now();
        let coeff_a = Util::parse_big_int(Self::COEFF_A);
        let diff_y = p1.y.clone().unwrap().sub(p2.y.as_ref().unwrap());

        let diff_x = p1.x.clone().unwrap().sub(p2.x.as_ref().unwrap());
        let q = FieldDivisionGadget::new(diff_y, diff_x, self.generator.clone()).get_output_wires()
            [0]
        .clone();

        let q2 = q.clone().unwrap().mul(q.as_ref().unwrap());

        let q3 = q2.clone().mul(q.as_ref().unwrap());

        let new_x = q2
            .clone()
            .sub(&coeff_a)
            .sub(p1.x.as_ref().unwrap())
            .sub(p2.x.as_ref().unwrap());

        let new_y =
            p1.x.as_ref()
                .unwrap()
                .muli(2)
                .add(p2.x.as_ref().unwrap())
                .add(&coeff_a)
                .mul(q.as_ref().unwrap())
                .sub(q3)
                .sub(p1.y.as_ref().unwrap());

        AffinePoint::new(new_x, new_y)
    }

    pub fn compute_y_coordinate(x: BigInteger) -> BigInteger {
        let start = std::time::Instant::now();
        let x_sqred = x.clone().mul(&x).rem(&CONFIGS.field_prime);

        let x_cubed = x_sqred.clone().mul(&x).rem(&CONFIGS.field_prime);

        let y_sqred = x_cubed
            .add(Util::parse_big_int(Self::COEFF_A).mul(x_sqred))
            .add(&x)
            .rem(&CONFIGS.field_prime);
        let y = IntegerFunctions::ressol(y_sqred, &CONFIGS.field_prime); //MYTODO 
        y
    }

    pub fn validate_inputs(&self) {
        let start = std::time::Instant::now();
        CircuitGenerator::add_one_assertion(
            self.generator.clone(),
            &self.t.base_point.x.as_ref().unwrap().check_non_zero(),
        );

        self.assert_valid_point_on_ec(
            self.t.base_point.x.as_ref().unwrap(),
            self.t.base_point.y.as_ref().unwrap(),
        );

        self.assert_point_order(&self.t.base_point, &self.t.base_table);
        CircuitGenerator::add_one_assertion(
            self.generator.clone(),
            &self.t.h_point.x.as_ref().unwrap().check_non_zero(),
        );

        self.assert_valid_point_on_ec(
            self.t.h_point.x.as_ref().unwrap(),
            self.t.h_point.y.as_ref().unwrap(),
        );

        self.assert_point_order(&self.t.base_point, &self.t.base_table);

        self.assert_point_order(&self.t.h_point, &self.t.h_table);
    }

    fn assert_point_order(&self, p: &AffinePoint, table: &Vec<AffinePoint>) {
        let start = std::time::Instant::now();
        let subgroup_order = Util::parse_big_int(Self::SUBGROUP_ORDER);
        let o = CircuitGenerator::create_constant_wire(self.generator.clone(), &subgroup_order);
        let bits = o.get_bit_wiresi(subgroup_order.bits()).as_array().clone();

        let mut result = table[bits.len() - 1].clone();
        for j in (1..=bits.len() - 2).rev() {
            let tmp = self.add_affine_points(&result, &table[j]);

            let is_one = &bits[j];
            result.x = Some(
                result.x.clone().unwrap().add(
                    is_one
                        .clone()
                        .unwrap()
                        .mul(tmp.x.clone().unwrap().sub(result.x.as_ref().unwrap())),
                ),
            );

            result.y = Some(
                result.y.clone().unwrap().add(
                    is_one
                        .clone()
                        .unwrap()
                        .mul(tmp.y.clone().unwrap().sub(result.y.as_ref().unwrap())),
                ),
            );
        }

        // verify that: result = -p
        CircuitGenerator::add_equality_assertion(
            self.generator.clone(),
            result.x.as_ref().unwrap(),
            p.x.as_ref().unwrap(),
        );

        CircuitGenerator::add_equality_assertion(
            self.generator.clone(),
            result.y.as_ref().unwrap(),
            &p.y.as_ref().unwrap().muli(-1),
        );

        // the reason the last iteration is handled separately is that the
        // addition of
        // affine points will throw an error due to not finding inverse for zero
        // at the last iteration of the scalar multiplication. So, the check in
        // the last iteration is done manually

        // TODO: add more tests to check this method
    }

    pub fn get_output_public_value(&self) -> &Option<WireType> {
        &self.t.output_public_value
    }

    pub fn get_shared_secret(&self) -> &Option<WireType> {
        &self.t.shared_secret
    }
}
impl GadgetConfig for Gadget<ECDHKeyExchangeGadget> {
    fn get_output_wires(&self) -> &Vec<Option<WireType>> {
        &self.t.output
    }
}
