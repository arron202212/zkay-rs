#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
#![allow(warnings, unused)]
use crate::{
    arc_cell_new,
    circuit::{
        InstanceOf, StructNameConfig,
        auxiliary::long_element::LongElement,
        config::config::Configs,
        eval::{circuit_evaluator::CircuitEvaluator, instruction::Instruction},
        operations::{
            gadget::{Gadget, GadgetConfig},
            primitive::{
                assert_basic_op::AssertBasicOp, basic_op::BasicOp, mul_basic_op::MulBasicOp,
            },
            wire_label_instruction::LabelType,
            wire_label_instruction::WireLabelInstruction,
        },
        structure::{
            circuit_generator::{CGConfig, CGConfigFields, CircuitGenerator},
            constant_wire::ConstantWire,
            variable_bit_wire::VariableBitWire,
            variable_wire::VariableWire,
            wire::{GetWireId, Wire, WireConfig, setBitsConfig},
            wire_array::WireArray,
            wire_type::WireType,
        },
    },
    util::{
        run_command::run_command,
        util::ARcCell,
        util::{BigInteger, Util},
    },
};
// use crate::circuit::config::config::Configs;
// use crate::circuit::eval::circuit_evaluator::CircuitEvaluator;

// use crate::circuit::eval::instruction::Instruction;
// use crate::circuit::operations::gadget::GadgetConfig;
// use crate::circuit::structure::constant_wire;
// use crate::circuit::structure::wire_type::WireType;
use crate::examples::gadgets::math::field_division_gadget::FieldDivisionGadget;
// import org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions;
use rccell::RcCell;
use std::fmt::Debug;
use std::fs::File;
use std::hash::{DefaultHasher, Hash, Hasher};
use std::ops::{Add, Mul, Neg, Rem, Sub};
use zkay_derive::ImplStructNameConfig;
/**
 * This gadget implements cryptographic key exchange using a customized elliptic
 * curve that is efficient to represent as a SNARK circuit. It follows the
 * high-level guidelines used for the design of Curve25519, while having the
 * cost model of QAP-based SNARKs in mind. Details in section 6:
 * https://eprint.iacr.org/2015/1093.pdf
 *
 * Detailed comments about the inputs and outputs of the circuit are below.
 *
 * Note: By default, this gadget validates only the secret values that are
 * provided by the prover, such as the secret key, and any intermediate
 * auxiliary witnesses that the prover uses in the circuit. In the default mode,
 * the gadget does not check the pub  input keys, e.g. it does not verify that
 * the base point or the other party's input have the appropriate order, as such
 * inputs could be typically pub  and can be checked outside the circuit if
 * needed. The Curve25519 paper as well claims that validation is not necessary
 * (although there is debate about some cases online). If any validation is
 * desired, there is a separate method called validateInputs() that do
 * validation, but is not called by default.
 *
 *
 *
 */
#[derive(Debug, Clone, Hash, ImplStructNameConfig)]
pub struct AffinePoint {
    pub x: Option<WireType>,
    pub y: Option<WireType>,
}
impl AffinePoint {
    pub fn newx(x: WireType) -> Self {
        Self {
            x: Some(x),
            y: None,
        }
    }

    pub fn new(x: WireType, y: WireType) -> Self {
        Self {
            x: Some(x),
            y: Some(y),
        }
    }
}

#[derive(Debug, Clone, ImplStructNameConfig)]
pub struct ECDHKeyExchangeGadget {
    // The Affine point representation is used as it saves one gate per bit
    pub basePoint: AffinePoint, // The Base point both parties agree to
    pub hPoint: AffinePoint,    // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    pub secretBits: Vec<Option<WireType>>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget outputs
    pub outputPublicValue: Option<WireType>, // the x-coordinate of the key exchange
    // material to be sent to the other party
    // outputPublicValue = ((this party's
    // secret)*Base).x
    pub sharedSecret: Option<WireType>, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    pub baseTable: Vec<AffinePoint>,
    pub hTable: Vec<AffinePoint>,
    pub output: Vec<Option<WireType>>,
    pub generators: CircuitGenerator,
}
impl ECDHKeyExchangeGadget {
    /**
     * This gadget receives two points: Base = (baseX) and H = (hX), and the
     * secret key Bits and outputs the scalar EC multiplications: secret*Base,
     * secret*H
     *
     * The secret key bits must be of length SECRET_BITWIDTH and are expected to
     * follow a little endian order. The most significant bit should be 1, and
     * the three least significant bits should be zero.
     *
     * This gadget can work with both  and dynamic inputs If pub  keys
     * are , the wires of base and h should be made ConstantWires when
     * creating them (before calling this gadget).
     *
     *
     */

    pub fn new(
        baseX: Option<WireType>,
        baseY: Option<WireType>,
        hX: Option<WireType>,
        hY: Option<WireType>,
        secretBits: Vec<Option<WireType>>,
        desc: &Option<String>,
        generator: RcCell<CircuitGenerator>,
    ) -> Gadget<Self> {
        let generators = generator.borrow().clone();
        let y_is_none = hY.is_none();
        let mut _self = Gadget::<Self> {
            generator,
            description: desc.clone().unwrap_or(String::new()),
            t: Self {
                outputPublicValue: None,
                sharedSecret: None,
                baseTable: vec![],
                hTable: vec![],
                secretBits,
                basePoint: AffinePoint { x: baseX, y: baseY },
                hPoint: AffinePoint { x: hX, y: hY },
                output: vec![],
                generators,
            },
        };

        _self.checkSecretBits();
        if y_is_none {
            _self.computeYCoordinates(); // For efficiency reasons, we rely on affine
        }
        // coordinates
        _self.buildCircuit();
        _self
    }
}

// impl  ECDHKeyExchangeGadget {
//     // same constructor as before, but accepts also baseY, and hY as inputs
//     pub fn news(
//         baseX: WireType,
//         baseY: WireType,
//         hX: WireType,
//         hY: WireType,
//         secretBits: Vec<Option<WireType>>,
//         desc: &Option<String>,
//     ) -> Self {
//         //super(desc);

//         let mut _self = Self{secretBits,
//         basePoint: AffinePoint::new(baseX, baseY),
//         hPoint: AffinePoint::new(hX, hY)};
//         _self.checkSecretBits();
//         _self.buildCircuit();
//         _self
//     }
//   }
impl Gadget<ECDHKeyExchangeGadget> {
    // Note: this parameterization assumes that the underlying field has
    // Configs.field_prime =
    // 21888242871839275222246405745257275088548364400416034343698204186575808495617

    pub const SECRET_BITWIDTH: usize = 253; // number of bits in the
    // exponent. Note that the
    // most significant bit
    // should
    // be set to 1, and the
    // three least significant
    // bits should be be zero.
    // See
    // the constructor

    pub const COEFF_A: &str = "126932"; // parameterization
    // in
    // https://eprint.iacr.org/2015/1093.pdf

    pub const CURVE_ORDER: &str =
        "21888242871839275222246405745257275088597270486034011716802747351550446453784";

    // As in curve25519, CURVE_ORDER = SUBGROUP_ORDER * 2^3
    pub const SUBGROUP_ORDER: &str =
        "2736030358979909402780800718157159386074658810754251464600343418943805806723";
    fn buildCircuit(&mut self) {
        //
        // The reason this operates on affine coordinates is that in our
        // setting, this's slightly cheaper than the formulas in
        // https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
        // following equations save 1 multiplication gate per bit. (we consider
        // multiplications by constants cheaper in our setting, so they are not
        // counted)
        //
        let start = std::time::Instant::now();
        self.t.baseTable = self.preprocess(&self.t.basePoint);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.hTable = self.preprocess(&self.t.hPoint);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.outputPublicValue = self
            .mul(&self.t.basePoint, &self.t.secretBits, &self.t.baseTable)
            .x
            .clone();
        self.t.sharedSecret = self
            .mul(&self.t.hPoint, &self.t.secretBits, &self.t.hTable)
            .x
            .clone();
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.output = vec![
            self.t.outputPublicValue.clone(),
            self.t.sharedSecret.clone(),
        ];
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
    }

    fn checkSecretBits(&self) {
        let start = std::time::Instant::now();
        /**
         * The secret key bits must be of length SECRET_BITWIDTH and are
         * expected to follow a little endian order. The most significant bit
         * should be 1, and the three least significant bits should be zero.
         */
        assert!(self.t.secretBits.len() == Self::SECRET_BITWIDTH);
        self.t.generators.addZeroAssertion(
            self.t.secretBits[0].as_ref().unwrap(),
            &Some("Asserting secret bit conditions".to_owned()),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.generators.addZeroAssertion(
            self.t.secretBits[1].as_ref().unwrap(),
            &Some("Asserting secret bit conditions".to_owned()),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.generators.addZeroAssertion(
            self.t.secretBits[2].as_ref().unwrap(),
            &Some("Asserting secret bit conditions".to_owned()),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.generators.addOneAssertion(
            self.t.secretBits[Self::SECRET_BITWIDTH - 1]
                .as_ref()
                .unwrap(),
            &Some("Asserting secret bit conditions".to_owned()),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        for i in 3..Self::SECRET_BITWIDTH - 1 {
            // verifying all other bit wires are binary (as this is typically a
            // secret
            // witness by the prover)
            self.t
                .generators
                .addBinaryAssertion(self.t.secretBits[i].as_ref().unwrap(), &None);
            println!("=={}={i}=start==elapsed== {:?} ", line!(), start.elapsed());
        }
    }

    fn computeYCoordinates(&mut self) {
        // Easy to handle if baseX is constant, otherwise, let the prover input
        // a witness and verify some properties
        let start = std::time::Instant::now();
        if self
            .t
            .basePoint
            .x
            .as_ref()
            .unwrap()
            .instance_of("ConstantWire")
        {
            let x = self
                .t
                .basePoint
                .x
                .as_ref()
                .unwrap()
                .try_as_constant_ref()
                .unwrap()
                .getConstant();
            self.t.basePoint.y = Some(
                self.t
                    .generators
                    .createConstantWire(&Self::computeYCoordinate(x), &None),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        } else {
            self.t.basePoint.y = Some(self.t.generators.createProverWitnessWire(&None));
            // generator.specifyProverWitnessComputation(&|evaluator: &mut CircuitEvaluator| {
            //     let x = evaluator.getWireValue(basePoint.x);
            //     evaluator.setWireValue(basePoint.y, &computeYCoordinate(x));
            // });
            let basePoint = &self.t.basePoint;
            let prover = crate::impl_prover!(
                            eval(  basePoint: AffinePoint)  {
            impl Instruction for Prover{
             fn evaluate(&self, evaluator: &mut CircuitEvaluator) {
                       let x = evaluator.getWireValue(self.basePoint.x.as_ref().unwrap());
            evaluator.setWireValue(self.basePoint.y.as_ref().unwrap(), &Gadget::<ECDHKeyExchangeGadget>::computeYCoordinate(x));


            }
            }
                        }
                    );
            self.t.generators.specifyProverWitnessComputation(prover);
            // {
            //     struct Prover;
            //     impl Instruction for Prover {
            //         &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(basePoint.x);
            //             evaluator.setWireValue(basePoint.y, computeYCoordinate(x));
            //         }
            //     }
            //     Prover
            // });
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            self.assertValidPointOnEC(
                self.t.basePoint.x.as_ref().unwrap(),
                self.t.basePoint.y.as_ref().unwrap(),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        }

        if self
            .t
            .hPoint
            .x
            .as_ref()
            .unwrap()
            .instance_of("ConstantWire")
        {
            let x = self
                .t
                .hPoint
                .x
                .as_ref()
                .unwrap()
                .try_as_constant_ref()
                .unwrap()
                .getConstant();
            self.t.hPoint.y = Some(
                self.t
                    .generators
                    .createConstantWire(&Self::computeYCoordinate(x), &None),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        } else {
            self.t.hPoint.y = Some(self.t.generators.createProverWitnessWire(&None));
            // generator.specifyProverWitnessComputation(&|evaluator: &mut CircuitEvaluator| {
            //     let x = evaluator.getWireValue(hPoint.x);
            //     evaluator.setWireValue(hPoint.y, &computeYCoordinate(x));
            // });
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            let hPoint = &self.t.hPoint;
            let prover = crate::impl_prover!(
                            eval(  hPoint: AffinePoint
                    )  {
            impl Instruction for Prover{
             fn evaluate(&self, evaluator: &mut CircuitEvaluator) {
                       let x = evaluator.getWireValue(self.hPoint.x.as_ref().unwrap());
            evaluator.setWireValue(self.hPoint.y.as_ref().unwrap(), &Gadget::<ECDHKeyExchangeGadget>::computeYCoordinate(x));


            }
            }
                        }
                    );
            self.t.generators.specifyProverWitnessComputation(prover);
            // {
            //         struct Prover;
            //         impl Instruction for Prover {
            //             &|evaluator: &mut CircuitEvaluator| {
            //                 let x = evaluator.getWireValue(hPoint.x);
            //                 evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //             }
            //         }
            //         Prover
            //     });
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            self.assertValidPointOnEC(
                self.t.hPoint.x.as_ref().unwrap(),
                self.t.hPoint.y.as_ref().unwrap(),
            );
        }
    }

    // this is only called, when WireType y is provided as witness by the prover
    // (not as input to the gadget)
    fn assertValidPointOnEC(&self, x: &WireType, y: &WireType) {
        let start = std::time::Instant::now();
        let ySqr = y.clone().mul(y);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let xSqr = x.clone().mul(x);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let xCube = xSqr.clone().mul(x);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.generators.addEqualityAssertion(
            &ySqr,
            &xCube
                .add(xSqr.mulb(
                    &BigInteger::parse_bytes(Self::COEFF_A.as_bytes(), 10).unwrap(),
                    &None,
                ))
                .add(x),
            &None,
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
    }

    fn preprocess(&self, p: &AffinePoint) -> Vec<AffinePoint> {
        let start = std::time::Instant::now();
        let mut precomputedTable: Vec<_> = (1..self.t.secretBits.len())
            .scan(p.clone(), |s, _j| {
                Some(Self::doubleAffinePoint(&s, self.generator.clone()))
            })
            .collect();
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        precomputedTable.insert(0, p.clone());
        precomputedTable
    }

    /**
     * Performs scalar multiplication (secretBits must comply with the
     * conditions above)
     */
    fn mul(
        &self,
        p: &AffinePoint,
        secretBits: &Vec<Option<WireType>>,
        precomputedTable: &Vec<AffinePoint>,
    ) -> AffinePoint {
        let start = std::time::Instant::now();
        let mut result = precomputedTable[secretBits.len() - 1].clone();
        for j in (0..=secretBits.len() - 2).rev() {
            let tmp = self.addAffinePoints(&result, &precomputedTable[j]);
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            let isOne = &secretBits[j];
            result.x = Some(
                result.x.clone().unwrap().add(
                    isOne
                        .clone()
                        .unwrap()
                        .mul(tmp.x.clone().unwrap().sub(result.x.as_ref().unwrap())),
                ),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            result.y = Some(
                result.y.clone().unwrap().add(
                    isOne
                        .clone()
                        .unwrap()
                        .mul(tmp.y.clone().unwrap().sub(result.y.as_ref().unwrap())),
                ),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        }
        result
    }

    fn doubleAffinePoint(p: &AffinePoint, generator: RcCell<CircuitGenerator>) -> AffinePoint {
        let start = std::time::Instant::now();
        let coeff_a = BigInteger::parse_bytes(Self::COEFF_A.as_bytes(), 10).unwrap();
        let x_2 = p.x.clone().unwrap().mul(p.x.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let l1 = FieldDivisionGadget::new(
            x_2.muli(3, &None)
                .add(p.x.as_ref().unwrap().mulb(&coeff_a, &None).muli(2, &None))
                .add(1),
            p.y.as_ref().unwrap().muli(2, &None),
            &None,
            generator,
        )
        .getOutputWires()[0]
            .clone();
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let l2 = l1.clone().unwrap().mul(l1.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let newX = l2
            .clone()
            .sub(&coeff_a)
            .sub(p.x.clone().unwrap())
            .sub(p.x.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let newY =
            p.x.as_ref()
                .unwrap()
                .muli(3, &None)
                .add(&coeff_a)
                .sub(&l2)
                .mul(l1.as_ref().unwrap())
                .sub(p.y.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        AffinePoint::new(newX, newY)
    }

    fn addAffinePoints(&self, p1: &AffinePoint, p2: &AffinePoint) -> AffinePoint {
        let start = std::time::Instant::now();
        let coeff_a = BigInteger::parse_bytes(Self::COEFF_A.as_bytes(), 10).unwrap();
        let diffY = p1.y.clone().unwrap().sub(p2.y.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let diffX = p1.x.clone().unwrap().sub(p2.x.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let q = FieldDivisionGadget::new(diffY, diffX, &None, self.generator.clone())
            .getOutputWires()[0]
            .clone();
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let q2 = q.clone().unwrap().mul(q.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let q3 = q2.clone().mul(q.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let newX = q2
            .clone()
            .sub(&coeff_a)
            .sub(p1.x.as_ref().unwrap())
            .sub(p2.x.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let newY =
            p1.x.as_ref()
                .unwrap()
                .muli(2, &None)
                .add(p2.x.as_ref().unwrap())
                .add(&coeff_a)
                .mul(q.as_ref().unwrap())
                .sub(q3)
                .sub(p1.y.as_ref().unwrap());
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        AffinePoint::new(newX, newY)
    }

    pub fn computeYCoordinate(x: BigInteger) -> BigInteger {
        let start = std::time::Instant::now();
        let xSqred = x.clone().mul(&x).rem(&Configs.field_prime);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let xCubed = xSqred.clone().mul(&x).rem(&Configs.field_prime);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let ySqred = xCubed
            .add(
                BigInteger::parse_bytes(Self::COEFF_A.as_bytes(), 10)
                    .unwrap()
                    .mul(xSqred),
            )
            .add(&x)
            .rem(&Configs.field_prime);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let y = x; //IntegerFunctions.ressol(ySqred, &Configs.field_prime); //TODO 
        y
    }

    pub fn validateInputs(&self) {
        let start = std::time::Instant::now();
        self.t.generators.addOneAssertion(
            &self.t.basePoint.x.as_ref().unwrap().checkNonZero(&None),
            &None,
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.assertValidPointOnEC(
            self.t.basePoint.x.as_ref().unwrap(),
            self.t.basePoint.y.as_ref().unwrap(),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.assertPointOrder(&self.t.basePoint, &self.t.baseTable);
        self.t.generators.addOneAssertion(
            &self.t.hPoint.x.as_ref().unwrap().checkNonZero(&None),
            &None,
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.assertValidPointOnEC(
            self.t.hPoint.x.as_ref().unwrap(),
            self.t.hPoint.y.as_ref().unwrap(),
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.assertPointOrder(&self.t.basePoint, &self.t.baseTable);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.assertPointOrder(&self.t.hPoint, &self.t.hTable);
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
    }

    fn assertPointOrder(&self, p: &AffinePoint, table: &Vec<AffinePoint>) {
        let start = std::time::Instant::now();
        let subgroup_order = BigInteger::parse_bytes(Self::SUBGROUP_ORDER.as_bytes(), 10).unwrap();
        let o = self.t.generators.createConstantWire(&subgroup_order, &None);
        let bits = o
            .getBitWiresi(subgroup_order.bits(), &None)
            .asArray()
            .clone();
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        let mut result = table[bits.len() - 1].clone();
        for j in (1..=bits.len() - 2).rev() {
            let tmp = self.addAffinePoints(&result, &table[j]);
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            let isOne = &bits[j];
            result.x = Some(
                result.x.clone().unwrap().add(
                    isOne
                        .clone()
                        .unwrap()
                        .mul(tmp.x.clone().unwrap().sub(result.x.as_ref().unwrap())),
                ),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
            result.y = Some(
                result.y.clone().unwrap().add(
                    isOne
                        .clone()
                        .unwrap()
                        .mul(tmp.y.clone().unwrap().sub(result.y.as_ref().unwrap())),
                ),
            );
            println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        }

        // verify that: result = -p
        self.t.generators.addEqualityAssertion(
            result.x.as_ref().unwrap(),
            p.x.as_ref().unwrap(),
            &None,
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        self.t.generators.addEqualityAssertion(
            result.y.as_ref().unwrap(),
            &p.y.as_ref().unwrap().muli(-1, &None),
            &None,
        );
        println!("=={}==start==elapsed== {:?} ", line!(), start.elapsed());
        // the reason the last iteration is handled separately is that the
        // addition of
        // affine points will throw an error due to not finding inverse for zero
        // at the last iteration of the scalar multiplication. So, the check in
        // the last iteration is done manually

        // TODO: add more tests to check this method
    }

    pub fn getOutputPublicValue(&self) -> &Option<WireType> {
        &self.t.outputPublicValue
    }

    pub fn getSharedSecret(&self) -> &Option<WireType> {
        &self.t.sharedSecret
    }
}
impl GadgetConfig for Gadget<ECDHKeyExchangeGadget> {
    fn getOutputWires(&self) -> &Vec<Option<WireType>> {
        &self.t.output
    }
}
