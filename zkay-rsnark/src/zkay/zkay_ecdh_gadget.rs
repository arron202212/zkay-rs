use crate::circuit::eval::circuit_evaluator::CircuitEvaluator;
use crate::circuit::eval::instruction::Instruction;
use crate::circuit::structure::constant_wire;
use crate::circuit::structure::wire_type::WireType;

/**
 * Shared key computation part of jsnark's ECDHKeyExchangeGadget
 */

pub struct ZkayECDHGadget {
    // The Affine point representation is used as it saves one gate per bit
    hPoint: AffinePoint, // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    secretBits: Vec<Option<WireType>>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget output
    sharedSecret: WireType, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    hTable: Vec<AffinePoint>,
}
impl ZkayECDHGadget {
    pub fn new(hX: WireType, secretKey: WireType, validateSecret: bool, desc: &Option<String>) -> Self {
        super(desc);
        self.secretBits = secretKey.getBitWires(SECRET_BITWIDTH).asArray();
        self.hPoint = AffinePoint::new(hX);
        if validateSecret {
            checkSecretBits(generator, secretBits);
        }
        computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinates
        buildCircuit();
    }
}
impl ZkayEcGadget for ZkayECDHGadget {
    fn buildCircuit() {
        /**
         * The reason this operates on affine coordinates is that in our
         * setting, this's slightly cheaper than the formulas in
         * https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
         * following equations save 1 multiplication gate per bit. (we consider
         * multiplications by constants cheaper in our setting, so they are not
         * counted)
         */
        hTable = preprocess(hPoint);
        sharedSecret = mul(hPoint, secretBits, hTable).x;
    }

    fn computeYCoordinates() {
        // Easy to handle if hPoint is constant, otherwise, let the prover input
        // a witness and verify some properties

        if hPoint.x.instance_of(ConstantWire) {
            let x = (hPoint.x).getConstant();
            hPoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            hPoint.y = generator.createProverWitnessWire();
            generator.specifyProverWitnessComputation( &|evaluator: &mut CircuitEvaluator| {
                        let x = evaluator.getWireValue(hPoint.x);
                        evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
                    });
            // {
            //     struct Prover;
            //     impl Instruction for Prover {
            //         &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(hPoint.x);
            //             evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //         }
            //     }
            //     Prover
            // });
            assertValidPointOnEC(hPoint.x, hPoint.y);
        }
    }

    pub fn getOutputWires() -> Vec<Option<WireType>> {
        let sharedKey = ZkaySHA256Gadget::new(vec![sharedSecret], 128).getOutputWires()[0];
        return vec![sharedKey];
    }

    pub fn validateInputs() {
        generator.addOneAssertion(hPoint.x.checkNonZero());
        assertValidPointOnEC(hPoint.x, hPoint.y);
        assertPointOrder(hPoint, hTable);
    }
}
