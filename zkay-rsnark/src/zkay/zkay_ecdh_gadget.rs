#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
#![allow(warnings, unused)]
use crate::circuit::eval::circuit_evaluator::CircuitEvaluator;
use crate::circuit::eval::instruction::Instruction;
use crate::circuit::operations::gadget::Gadget;
use crate::circuit::operations::gadget::GadgetConfig;
use crate::circuit::structure::circuit_generator::CircuitGenerator;
use crate::circuit::structure::constant_wire;
use crate::circuit::structure::wire_type::WireType;
use crate::zkay::zkay_ec_gadget::AffinePoint;
use crate::zkay::zkay_ec_gadget::ZkayEcGadget;
use crate::zkay::zkay_sha256_gadget::ZkaySHA256Gadget;

use rccell::RcCell;

use zkay_derive::ImplStructNameConfig;
/**
 * Shared key computation part of jsnark's ECDHKeyExchangeGadget
 */

pub struct ZkayECDHGadget {
    // The Affine point representation is used as it saves one gate per bit
    hPoint: AffinePoint, // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    secretBits: Vec<Option<WireType>>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget output
    sharedSecret: Option<WireType>, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    hTable: Vec<AffinePoint>,
    outputs: Vec<Option<WireType>>,
    generators: CircuitGenerator,
}
impl ZkayECDHGadget {
    pub fn new(
        hX: &WireType,
        secretKey: &WireType,
        validateSecret: bool,
        desc: &Option<String>,
        generator: RcCell<CircuitGenerator>,
    ) -> Gadget<ZkayEcGadget<Self>> {
        let generators = generator.borrow().clone();
        let mut _self = ZkayEcGadget::<Self>::new(
            desc,
            Self {
                secretBits: secretKey
                    .getBitWires(ZkayEcGadget::<Self>::SECRET_BITWIDTH)
                    .asArray(),
                hPoint: AffinePoint::new(hX),
                sharedSecret: None,
                hTable: vec![],
                outputs: vec![],
                generators,
            },
            generator,
        );

        if validateSecret {
            _self.checkSecretBits(&generator, &_self.secretBits);
        }
        _self.computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinates
        _self.buildCircuit();
        _self
    }
}

impl Gadget<ZkayEcGadget<ZkayECDHGadget>> {
    fn buildCircuit(&mut self) {
        /**
         * The reason this operates on affine coordinates is that in our
         * setting, this's slightly cheaper than the formulas in
         * https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
         * following equations save 1 multiplication gate per bit. (we consider
         * multiplications by constants cheaper in our setting, so they are not
         * counted)
         */
        let hTable = self.preprocess(&self.t.t.hPoint);
        let sharedSecret = self
            .mul(&self.t.t.hPoint, &self.t.t.secretBits, &hTable)
            .x
            .clone();
        let sharedKey = ZkaySHA256Gadget::new(vec![sharedSecret], 128).getOutputWires()[0].clone();
        self.t.t.outputs = vec![sharedKey];
        (self.t.t.hTable, self.t.t.sharedSecret) = (hTable, sharedSecret);
    }

    fn computeYCoordinates(&self) {
        // Easy to handle if hPoint is constant, otherwise, let the prover input
        // a witness and verify some properties
        let generator = &self.t.generators;
        let hPoint = &self.t.t.hPoint;
        if hPoint.x.instance_of("ConstantWire") {
            let x = (hPoint.x).getConstant();
            hPoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            hPoint.y = generator.createProverWitnessWire(&None);
            // generator.specifyProverWitnessComputation( &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(hPoint.x);
            //             evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //         });
            let prover = crate::impl_prover!(
                            eval( hPoint: AffinePoint
                    )  {
            impl Instruction for Prover{
             fn evaluate(&self, evaluator: &mut CircuitEvaluator) {
                    let x = evaluator.getWireValue(&self.hPoint.x);
                    evaluator.setWireValue(&self.hPoint.y, ZkayEcGadget::<ZkayECDHGadget>::computeYCoordinate(x));

            }
            }
                        }
                    );
            generator.specifyProverWitnessComputation(prover);
            // {
            //     struct Prover;
            //     impl Instruction for Prover {
            //         &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(hPoint.x);
            //             evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //         }
            //     }
            //     Prover
            // });
            self.assertValidPointOnEC(hPoint.x, hPoint.y);
        }
    }
    fn validateInputs(&self) {
        self.t
            .generators
            .addOneAssertion(&self.t.hPoint.x.checkNonZero());
        self.assertValidPointOnEC(&self.t.hPoint.x, &self.t.hPoint.y);
        self.assertPointOrder(&self.t.hPoint, &self.t.hTable);
    }
}

impl GadgetConfig for Gadget<ZkayEcGadget<ZkayECDHGadget>> {
    fn getOutputWires(&self) -> &Vec<Option<WireType>> {
        &self.t.t.outputs
    }
}
