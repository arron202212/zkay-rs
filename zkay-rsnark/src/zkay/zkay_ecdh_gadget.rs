use crate::circuit::eval::circuit_evaluator::CircuitEvaluator;
use crate::circuit::eval::instruction::Instruction;
use crate::circuit::structure::constant_wire;
use crate::circuit::structure::wire_type::WireType;

/**
 * Shared key computation part of jsnark's ECDHKeyExchangeGadget
 */

pub struct ZkayECDHGadget {
    // The Affine point representation is used as it saves one gate per bit
    hPoint: AffinePoint, // H is the other party's pub  value
    // H = (other party's secret)* Base <- scalar EC
    // multiplication
    secretBits: Vec<Option<WireType>>, // the bits of the secret generated by this party
    // (follows little-endian order)

    // gadget output
    sharedSecret: &Option<WireType>, // the x-coordinate of the derived key ((this
    // party's secret)*H).x
    hTable: Vec<AffinePoint>,
    outputs: Vec<Option<WireType>>,
}
impl ZkayECDHGadget {
    pub fn new(
        hX: &WireType,
        secretKey: &WireType,
        validateSecret: bool,
        desc: &Option<String>,
        generator: RcCell<CircuitGenerator>,
    ) -> Gadget<ZkayEcGadget<Self>> {
        let mut _self = ZkayEcGadget::<Self>::new(
            desc,
            Self {
                secretBits: secretKey.getBitWires(SECRET_BITWIDTH).asArray(),
                hPoint: AffinePoint::new(hX),
                sharedSecret: None,
                hTable: vec![],
                outputs: vec![],
            },
            generator,
        );

        if validateSecret {
            _self.checkSecretBits(generator, secretBits);
        }
        _self.computeYCoordinates(); // For efficiency reasons, we rely on affine
        // coordinates
        _self.buildCircuit();
        _self
    }
}

impl GadgetConfig for Gadget<ZkayEcGadget<ZkayECDHGadget>> {
    fn buildCircuit(&mut self) {
        /**
         * The reason this operates on affine coordinates is that in our
         * setting, this's slightly cheaper than the formulas in
         * https://cr.yp.to/ecdh/curve25519-20060209.pdf. Concretely, the
         * following equations save 1 multiplication gate per bit. (we consider
         * multiplications by constants cheaper in our setting, so they are not
         * counted)
         */
        let hTable = self.preprocess(&self.t.t.hPoint);
        let sharedSecret = self
            .mul(&self.t.t.hPoint, &self.t.t.secretBits, &hTable)
            .x
            .clone();
        let sharedKey = ZkaySHA256Gadget::new(vec![sharedSecret], 128).getOutputWires()[0].clone();
        self.t.t.outputs = vec![sharedKey];
        (self.t.t.hTable, self.t.t.sharedSecret) = (hTable, sharedSecret);
    }

    fn computeYCoordinates() {
        // Easy to handle if hPoint is constant, otherwise, let the prover input
        // a witness and verify some properties
        let hPoint = &self.t.t.hPoint;
        if hPoint.x.instance_of(ConstantWire) {
            let x = (hPoint.x).getConstant();
            hPoint.y = generator.createConstantWire(computeYCoordinate(x));
        } else {
            hPoint.y = generator.createProverWitnessWire(&None);
            // generator.specifyProverWitnessComputation( &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(hPoint.x);
            //             evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //         });
            let prover = crate::impl_prover!(
                            eval( hPoint: AffinePoint
                    )  {
            impl Instruction for Prover{
             fn evaluate(&self, evaluator: &mut CircuitEvaluator) {
                    let x = evaluator.getWireValue(hPoint.x);
                    evaluator.setWireValue(hPoint.y, computeYCoordinate(x));

            }
            }
                        }
                    );
            self.generator.specifyProverWitnessComputation(prover);
            // {
            //     struct Prover;
            //     impl Instruction for Prover {
            //         &|evaluator: &mut CircuitEvaluator| {
            //             let x = evaluator.getWireValue(hPoint.x);
            //             evaluator.setWireValue(hPoint.y, computeYCoordinate(x));
            //         }
            //     }
            //     Prover
            // });
            self.assertValidPointOnEC(hPoint.x, hPoint.y);
        }
    }
    pub fn validateInputs(&self) {
        generator.addOneAssertion(hPoint.x.checkNonZero());
        self.assertValidPointOnEC(hPoint.x, hPoint.y);
        self.assertPointOrder(hPoint, hTable);
    }
}

impl GadgetConfig for Gadget<ZkayEcGadget<ZkayECDHGadget>> {
    fn getOutputWires(&self) -> &Vec<Option<WireType>> {
        &self.t.t.outputs
    }
}
