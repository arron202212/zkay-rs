use rccell::RcCell;
use zkay_ast::ast::{
    ASTFlatten, Expression, HybridArgType, HybridArgumentIdf, Identifier, TypeName,
};
#[derive(Clone)]
pub struct BaseNameFactory {
    pub base_name: String,
    pub count: i32,
}
// class BaseNameFactory:
// """A Base name factory can generate fresh, unused name strings with a given prefix"""
impl BaseNameFactory {
    pub fn new(base_name: String) -> Self {
        Self {
            base_name,
            count: 0,
        }
    }
    // """
    // Generate a fresh name for a value of type t.

    // :param t: transformed type
    // :param inc: if true, the internal counter, which is used as part of fresh ids, is incremented
    // """
    pub fn get_new_name(&mut self, t: &RcCell<TypeName>, inc: bool) -> String {
        let postfix = match t.borrow() {
            _t if _t.is_key() => "key",
            _t if _t.is_cipher() => "cipher",
            _t if _t.is_randomness() => "rnd",
            _ => "plain",
        };
        let name = format!("{}{}_{postfix}", self.base_name, self.count);
        if inc {
            self.count += 1;
        }
        name
    }
}

// class NameFactory(BaseNameFactory):
// """A Name factory can generate fresh, unused HybridArgumentIdfs with a given prefix."""
#[derive(Clone)]
pub struct NameFactory {
    pub base_name_factory: BaseNameFactory,
    pub arg_type: HybridArgType,
    pub size: i32,
    pub idfs: Vec<Identifier>,
}
impl NameFactory {
    pub fn new(base_name: String, arg_type: HybridArgType) -> Self {
        // super().__init__(base_name)
        // self.arg_type = arg_type
        // self.size = 0
        // self.idfs = []
        Self {
            base_name_factory: BaseNameFactory::new(base_name),
            arg_type,
            size: 0,
            idfs: vec![],
        }
    }
    // """Generate a new HybridArgumentIdf which references priv_expr and has transformed type t."""
    pub fn get_new_idf(
        &mut self,
        t: &RcCell<TypeName>,
        priv_expr: Option<RcCell<Expression>>,
    ) -> HybridArgumentIdf {
        let name = self.base_name_factory.get_new_name(t, true);
        let idf = HybridArgumentIdf::new(name, t.clone(), self.arg_type.clone(), priv_expr);
        self.size += t.borrow().size_in_uints();
        self.idfs.push(Identifier::HybridArgumentIdf(idf.clone()));
        idf
    }
    // """
    // Generate a new HybridArgumentIdf with the given name.

    // This also adds the HybridArgumentIdf to the internal list of identifiers generated by this NameFactory.
    // """
    pub fn add_idf(
        &mut self,
        name: String,
        t: &RcCell<TypeName>,
        priv_expr: Option<&ASTFlatten>,
    ) -> HybridArgumentIdf {
        let idf = HybridArgumentIdf::new(
            name,
            t.clone(),
            self.arg_type.clone(),
            priv_expr
                .as_ref()
                .unwrap()
                .try_as_expression_ref()
                .clone()
                .cloned(),
        );
        self.base_name_factory.count += 1;
        self.size += t.borrow().size_in_uints();
        self.idfs.push(Identifier::HybridArgumentIdf(idf.clone()));
        idf
    }
}
